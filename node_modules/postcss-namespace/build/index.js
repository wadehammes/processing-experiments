'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WARNING_TEXT = '@namespace is deprecated! please use @prefix';

const defaultOpts = {
  token: '-'
};

exports.default = _postcss2.default.plugin('postcss-namespace', function () {
  let opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  opts = (0, _extends3.default)({}, defaultOpts, opts);

  return (css, result) => {
    css.walkAtRules(/namespace|prefix/, rule => {
      if (rule.name === 'namespace') {
        result.warn(WARNING_TEXT, { node: rule });
        return rule;
      }
      const prefix = rule.params.match(/^[^\s]*/)[0];
      const ignored = (params => {
        const matches = params.match(/not\((.+)\)/);
        if (!matches) {
          return [];
        }

        const ignored = _lodash2.default.compact(matches[1].split(/\s*,\s*/));
        return _lodash2.default.map(ignored, target => {
          const matches = target.match(/\/(.+)\//);
          if (!matches) {
            return target;
          }
          return new RegExp(_lodash2.default.escapeRegExp(matches[1]));
        });
      })(rule.params);
      process(prefix, rule, ignored);
      rule.remove();
    });
  };

  function process(prefix, target, ignored) {
    if (!prefix) {
      return;
    }

    while (target = target.next()) {
      if (isPrefixAtRule(target)) {
        break;
      }

      if (target.constructor.name === 'AtRule') {
        if (typeof target.nodes !== 'undefined' && target.nodes.length) {
          process(prefix, wrapNodes(target.nodes), ignored);
        }
      }

      if (target.constructor.name !== 'Rule') {
        continue;
      }

      const re = /[#.][^\s#.%[:]+/g;
      target.selector = target.selector.replace(re, selector => {
        if (ignored.length && isIgnored(selector)) {
          return selector;
        }
        return `${ selector[0] }${ prefix }${ opts.token }${ selector.slice(1) }`;
      });
    }

    function isPrefixAtRule(target) {
      return Boolean(target.constructor.name === 'AtRule' && target.name === 'prefix');
    }

    function isIgnored(selector) {
      return _lodash2.default.some(_lodash2.default.map(ignored, target => {
        if (target.constructor.name === 'String') {
          return selector === target;
        } else if (target.constructor.name === 'RegExp') {
          return target.test(selector);
        }
      }));
    }

    function wrapNodes(nodes) {
      return {
        next() {
          return nodes[0];
        }
      };
    }
  }
});